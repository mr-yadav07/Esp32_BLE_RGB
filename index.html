// ESP32 BLE + WS2812B - Smooth color transitions, notif, robust handling
#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <Adafruit_NeoPixel.h>

#define LED_PIN      13
#define NUM_LEDS     12
#define ONBOARD_LED  2

Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

// UUIDs (same as web app)
#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define COLOR_CHAR_UUID     "87654321-4321-4321-4321-abcdefabcdef"
#define LED_CHAR_UUID       "abcdefab-cdef-cdef-cdef-1234567890ab"

BLEServer* pServer = nullptr;
BLECharacteristic* colorChar = nullptr;
BLECharacteristic* ledChar = nullptr;

volatile bool clientConnected = false;

// Color state
uint8_t curR = 0, curG = 0, curB = 0;      
uint8_t tgtR = 0, tgtG = 0, tgtB = 0;      
unsigned long lastStepMs = 0;
const unsigned long stepIntervalMs = 20;   

class ServerCallbacks: public BLEServerCallbacks {
  void onConnect(BLEServer* s) {
    clientConnected = true;
    Serial.println("BLE Client connected");
  }
  void onDisconnect(BLEServer* s) {
    clientConnected = false;
    Serial.println("BLE Client disconnected");
    BLEDevice::startAdvertising();
  }
};

class ColorWriteCB : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pChar) override {
    std::string v = pChar->getValue();
    if (v.length() >= 3) {

      tgtR = (uint8_t)v[0];
      tgtG = (uint8_t)v[1];
      tgtB = (uint8_t)v[2];

      Serial.printf("Received target color R=%u G=%u B=%u\n", tgtR, tgtG, tgtB);

      uint8_t report[3] = { curR, curG, curB };

      // FIX: Removed getProperties() check (private in 1.0.3)
      colorChar->setValue(report, 3);
      colorChar->notify();
      
    } else {
      Serial.println("Color write length invalid");
    }
  }
};

class LedWriteCB : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pChar) override {
    std::string v = pChar->getValue();
    if (v.length() >= 1) {
      uint8_t s = (uint8_t)v[0];
      digitalWrite(ONBOARD_LED, s ? HIGH : LOW);
      Serial.printf("Onboard LED set: %s\n", s ? "ON" : "OFF");

      uint8_t st = s ? 1 : 0;
      ledChar->setValue(&st,1);
      ledChar->notify();

    } else {
      Serial.println("LED write length invalid");
    }
  }
};

void applyStrip(uint8_t r, uint8_t g, uint8_t b) {
  for (int i=0;i<NUM_LEDS;i++) strip.setPixelColor(i, strip.Color(r,g,b));
  strip.show();
}

void setup() {
  Serial.begin(115200);
  pinMode(ONBOARD_LED, OUTPUT);
  digitalWrite(ONBOARD_LED, LOW);

  strip.begin();
  strip.show();

  BLEDevice::init("ESP32_LED");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());

  BLEService *svc = pServer->createService(SERVICE_UUID);

  colorChar = svc->createCharacteristic(
    COLOR_CHAR_UUID,
    BLECharacteristic::PROPERTY_WRITE |
    BLECharacteristic::PROPERTY_READ |
    BLECharacteristic::PROPERTY_NOTIFY
  );
  colorChar->addDescriptor(new BLE2902());
  colorChar->setCallbacks(new ColorWriteCB());

  ledChar = svc->createCharacteristic(
    LED_CHAR_UUID,
    BLECharacteristic::PROPERTY_WRITE |
    BLECharacteristic::PROPERTY_READ |
    BLECharacteristic::PROPERTY_NOTIFY
  );
  ledChar->addDescriptor(new BLE2902());
  ledChar->setCallbacks(new LedWriteCB());

  uint8_t initColor[3] = {curR, curG, curB};
  colorChar->setValue(initColor, 3);

  uint8_t initLed = 0;
  ledChar->setValue(&initLed, 1);

  svc->start();

  BLEAdvertising *adv = BLEDevice::getAdvertising();
  adv->addServiceUUID(SERVICE_UUID);
  adv->setScanResponse(false);
  BLEDevice::startAdvertising();

  Serial.println("BLE service started, advertising...");
  lastStepMs = millis();
}

void loop() {
  unsigned long now = millis();
  if (now - lastStepMs >= stepIntervalMs) {
    lastStepMs = now;

    auto stepChannel = [](uint8_t cur, uint8_t tgt)->uint8_t {
      if (cur == tgt) return cur;
      int diff = (int)tgt - (int)cur;
      int step = diff / 6;
      if (step == 0) step = (diff>0)?1:-1;
      int next = (int)cur + step;
      if ((diff>0 && next>tgt) || (diff<0 && next<tgt)) next = tgt;
      return (uint8_t)next;
    };

    uint8_t nextR = stepChannel(curR, tgtR);
    uint8_t nextG = stepChannel(curG, tgtG);
    uint8_t nextB = stepChannel(curB, tgtB);

    if (nextR!=curR || nextG!=curG || nextB!=curB) {
      curR = nextR;
      curG = nextG;
      curB = nextB;
      applyStrip(curR, curG, curB);

      if (clientConnected) {
        uint8_t report[3] = { curR, curG, curB };
        colorChar->setValue(report,3);
        colorChar->notify();
      }
    }
  }
}